\documentclass[a4paper,twoside,12pt]{article}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[a4paper, inner=1.5cm, outer=3cm, top=2cm, bottom=3cm, bindingoffset=0.5cm]{geometry}

\renewcommand{\footnoterule}{\noindent\smash{\rule[3pt]{\textwidth}{0.4pt}}}
\fancyhf{}
\fancyhead[LE]{\scshape\nouppercase{\leftmark}}
\fancyhead[RO]{\nouppercase{\rightmark}}
\fancyfoot[LE,RO]{\thepage}
\pagestyle{fancy}

\begin{document}
\title{
    \includegraphics[width=5cm]{img/NicePng_bumblebee-png_1235241.png}
    \\
    \underline{e\scshape{BPF Notes}}
    }
\author{\scshape{TJ Robinson}}

\maketitle

\section{What is eBPF?}
\begin{itemize}
    \item eBPF (extended Berkeley Packet Filter)
    \item Outperforms \textsl{IPtables} based soliutions
\end{itemize}

\subsection{Logs vs. Metrics vs. Observability}
\begin{itemize}
    \item Logs: Detailed, unstructured, aggregated data about individual events.
    \begin{itemize}
        \item  Useful for troubleshooting and forensic analysis.
        \item Can be voluminous and harder to analyze at scale.
    \end{itemize}
    \item Metrics: Aggregated, structured data for to monitor a program or system performance at a specific point in time.
    \begin{itemize}
        \item Useful for identifying trends and triggering alerts.
        \item Typically less detailed but more efficient to store and query.
    \end{itemize}
    \item Observability: Combines logs, metrics, and traces to provide a comprehensive view of system behavior.
    \begin{itemize}
        \item Capacity to ask arbitrary questions and recieve complex answers about a system's state.
    \end{itemize}
\end{itemize}

\subsection{Namespaces \& Cgroups}
Both are fundamental for containerization and resource management in Linux. 
\begin{itemize}
    \item Namespaces: Isolate system resources for processes (e.g., PID, network, mount).
    \begin{itemize}
        \item inside a namespace, you experience the operating system like there were no other tasks running on the computer
    \end{itemize}
    \item Cgroups: Control and limit resource usage (CPU, memory, I/O) for process groups.
    \begin{itemize}
        \item gives you fine grain control over resource usage like CPU, disk I/O, network, and etc.
    \end{itemize}
\end{itemize}

Tracepoints are static marks in the kernel code that can be used to inject code to inspect the kernel's execution.

\section{eBPF Runtime}
The eBPF runtime is responsible for loading, verifying, and executing eBPF programs in the Linux kernel. It provides a virtual machine (VM) environment where eBPF bytecode can run safely and efficiently.
\begin{description}
    \item [Verifier:] Ensures eBPF programs are safe to run in the kernel.
        \begin{itemize}
            \item Checks for safety properties like bounded loops, valid memory access, and resource limits.
        \end{itemize}
    \item [JIT Compiler:] Translates eBPF bytecode into native machine code for improved performance.
        \begin{itemize}
            \item only invoked after the JIT compiler has verified the program is safe to run.
        \end{itemize}
    \item [Maps:] Data structures that allow eBPF programs to store and share data between the kernel and user-space.    
    \item [Attachment Points:] Locations in the kernel where eBPF programs can be attached (e.g., kprobes, tracepoints, XDP).
\end{description}

\section{eBPF Program Types}

\subsection{Socket Filter Programs}
\begin{itemize}
    \item Attach to network sockets to filter packets.
    \item Commonly used for packet filtering and monitoring.
    \item You can not modify the packets, only accept, drop, forward, or observe them.
\end{itemize}

\subsection{Kprobes and Uprobes}
\begin{itemize}
    \item Kprobes: Attach to kernel functions to trace and monitor kernel events.
    \begin{itemize}
        \item define dynamic breakpoints in the kernel code.
        \item defined with the type \texttt{BPF\_PROG\_TYPE\_KPROBE}.
        \item BPF VM ensures kprobe programs are safe to run.
        \item You'll need to decide whether to attach at function entry or exit of the syscall.
        \begin{itemize}
            \item Entry probes: Capture arguments passed to the function.
            \item Exit probes: Capture return values from the function.
        \end{itemize}
    \end{itemize}
    \item Uprobes: Attach to user-space functions to trace and monitor application events.
\end{itemize}

\subsection{Tracepoint Programs}
\begin{itemize}
    \item Defined by the type \texttt{BPF\_PROG\_TYPE\_TRACEPOINT}.
    \item All system tracepoints are defined in the the /sys/kernel/debug/tracing/events/ directory.
    \item Attach to predefined tracepoints in the kernel.
    \item Used for monitoring specific kernel events.
    \item More stable than kprobes as tracepoints are less likely to change.
\end{itemize}

\subsection{XDP \textsl{(eXpress Data Path)} Programs}
\begin{itemize}
    \item Defined by the type \texttt{BPF\_PROG\_TYPE\_XDP}.
    \item Attach to the earliest point in the network stack.
    \item Used for high-performance packet processing.
    \item Ability to modify or drop packets before they reach the kernel networking stack leads to improved performance.
\end{itemize}

\section{eBPF Map Types}
eBPF maps are data structures that allow eBPF programs to store and share data between the kernel and user-space.

\subsection{Hash Maps}
    \begin{description}
        \item [Hash Maps:] Key-value stores optimized for fast lookups.
    \end{description}

\subsection{Array Maps}
    \begin{description}
        \item [Array Maps:] Fixed-size arrays indexed by integers.
    \end{description}

\subsection{Per-CPU Maps}
    \begin{description}
        \item [Per-CPU Maps:] Store separate values for each CPU core.
    \end{description}

\subsection{}
    \begin{description}
        \item [LRU Maps:] Least Recently Used maps for caching data with eviction policies.
    \end{description}
\end{document}